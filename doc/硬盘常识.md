<div align="right">2023-04-07</div>

---

# 硬盘常识

硬盘通过 **分区结构** 进行分区, 在 NTFS 中把分区称为 **卷(volume)**.

常用的 **分区结构** 如下:

* MBR 硬盘分区
* 动态硬盘分区
* GPT 硬盘分区

**分区** 内的部分称为 **逻辑硬盘**, 一个 **逻辑硬盘** 对应一个 **文件系统**.

所以 **文件系统** 是在 **分区** 里起作用的.

## NTFS

基本思想: 在 NTFS 里一切皆 **文件**.

* **主文件表(Master File Table, MFT)** 负责对 **文件** 的索引.
* **MFT** 列出了 **引导扇区文件($Boot)**, 位于硬盘的开头处.
* **引导扇区文件($Boot)** 也列出了到哪里找到 **MFT**.
* **VCN(virtual cluster number)** 虚拟簇号, **LCN 逻辑簇号**.
* **MFT** 是一系列 **FILE 记录(FILE records)**, 每个文件被一个或多个 **FILE 记录** 表示.
* **FILE 记录** 等价于 Unix 里的 **Inode**.
* 文件的第一个 **FILE 记录** 叫做 **Base FILE 记录**, 其他的叫做 **Extension FILE 记录**.
* 一个 **FILE 记录** 由 (**头部**, 几个可变长度**属性**, **结尾标志(0xFFFFFFFF)**) 组成.
* **常驻** 与 **非常驻**:
  * 当一个文件很小时, 其所有属性和属性值可以存放在 MFT 的文件记录中, 当属性值能直接放在 MFT 中时, 该属性就称为 **常驻属性(resident attribute)**.
  * 有些属性总是 **常驻属性**.
* 每个 **属性** 都以一个 **标准头** 开始.

总体结构:

* Boot(1 扇区)
* MFT
* 自由空间
* 更多的元数据
* 自由空间

`$Boot` 文件结构:

![$Boot](./.img/Screenshot%202023-04-07%20071122.png)

**FILE 记录** 结构:

![FILE 记录](./.img/Screenshot%202023-04-07%20092420.png)

### data runs

![data runs](./.img/Screenshot%202023-04-07%20184257.png)

* **长度** 和 **簇号偏移** 的大小分别存在第一个字节的低半字节 和 高半字节.
* **簇号偏移** 是有符号数.
* 对于压缩或稀疏流(sparse runs), **簇号偏移** 是 0, **簇号偏移** 的大小也是 0.
* 每个 **压缩单元(compression unit)** 以 16 的倍数簇号开始.
* 如果 **压缩单元** 可用, 单元里可能出现一个或多个 **空流**.
* 如果有 **数据流** 里超过 16 个簇, 则此流的 **单元** 不可压缩.

### 更新序列(US), 更新序列号(USN) 和 更新数组

* 在日志记录中的 **USN** (长 8 字节):
  * **USN** 是 `$UsnJrnl` 文件中 `$J` 数据属性数据中记录的偏移值.
  * **USN** 信息也会记录在 **MFT 记录**(即 **文件记录**) 的 `$STANDARD_INFORMATION` 属性中.
* 在文件记录头中的 **US** (长 2 字节):
  * **US** 的值与 **文件记录** 每个扇区最后两个字节相同.
  * 用来作为校验值, 当载入内存时, 检查 **US** 是否和每个扇区最后两个字节相同, 相同则说明 **文件记录** 没有问题.
  * 每次修改 **文件记录** 时 **US** 加 1, 循环计数, 当为 0 时再加一个 1.
* **更新数组**:
  * **更新数组** 包含每个扇区最后两个字节的真实值.

### 文件夹

**文件夹** 通过 **索引** 属性进行描述, 根据观察, 文件夹的 **文件记录** 可能出现以下属性:

* `$OBJECT_ID`(0x40): 随机出现, 不知道有什么规律(有的不是文件夹的文件上也有).
* `$INDEX_ROOT`(0x90): 出现在所有 **文件夹** 的 **文件记录** 里.
* `$INDEX_ALLOCATION`(0xA0): 当 **文件夹** 里文件很多时出现.
* `$BITMAP`(0xB0): 伴随 `$INDEX_ALLOCATION` 出现.

### 索引

* **索引** 分为 **小索引** 和 **大索引**(需要 `$INDEX_ALLOCATION` 和 `$BITMAP`):
  * **小索引**:
    * **索引项(Index Entry)** 中的 **流(Stream)** 是被索引的 **文件记录** 中的被索引属性的属性数据部分. (比如 `$I30` 索引, 索引的是 `$FILE_NAME` 属性, 则在 **索引项** 中的 **流** 是此 **索引项** 索引的文件的 `$FILE_NAME` 属性的数据).
  * **大索引**:
    * **索引项(Index Entry)** 中的 **流(Stream)** 是很多 **索引块(Index Block)** 组成的数组, 在 `$INDEX_ROOT` 里的 **流** 的数据是 **索引记录号**?
    * **索引块** 包含一个 **头** 后跟一系列 **索引项(INDEX_ENTRY)**, 在 INDEX_HEADER 里描述.
    * **索引块** 中每个扇区的最后两个字节也要被替换成 **更新数组**.
    * 每条 **索引记录(Index Record)** 包含一个 **标准索引头(Standard Index Header)** 和 一组包含 (**索引键(Index Key)**, **索引数据(Index Data)**)的**块**. 一个 **索引块** 包含一个 **索引记录**, 即 **索引块** 大小就是 **索引记录** 的分配大小.
    * 单条 **索引记录** 的大小定义在 `$Boot` 中, 并似乎总是为 4KB.

> 猜想: 既然只有被索引了的文件才能在目录中看见, 那么如果把文件的索引删了是不是能达到隐藏文件的目的? 反之, 既然 `$Logfile` 之类的文件没有被索引, 是不是只要我们手动建立索引就能在目录中看到?

基本结构:

**索引节点(Index Node)**:

* **标准索引头(Standard Index Header)** (16 字节)
* **索引头(Index Header)** (16 字节):
  * 到第一个 **索引项** 的偏移. (4 字节)
  * **索引节点** 的总大小, 单位(字节). (4 字节)
  * **索引节点** 的分配大小, 单位(字节). (4 字节)
  * **节点种类** (1 字节): `0x00` 表示此为叶子节点, `0x01` 表示此非叶子节点.
  * 填充, 实现 8 字节对齐. (3 字节)
* **索引记录列表(Index Records List)**:
  * **索引项**
  * ...
  * **索引项** (flag = `LAST_ENTRY_IN_THE_NODE`)

### `$INDEX_ROOT`

### 硬链接

* 通过创建多个 `$FILE_NAME` 属性实现文件硬链接.

### `$STANDARD_INFORMATION`

* 里面的信息永远保持最新.
* 而 `$FILE_NAME` 里的除 **父文件夹文件引用** 字段之外的所有字段只有在修改文件名时才更新.

### `$FILE_NAME`

* 如果文件有 **扩展属性(Extended Attributes, EA)**, 则 **EA 字段** 将包含这些 **扩展属性** 的所需大小.
* 如果文件标志包含 **Reparse Point**, 则 **Reparse 字段** 将给出它的类型.

### `$ATTRIBUTE_LIST`

* 当 **文件记录** 里无法容纳过多的常驻数据, 则会使用此属性, 它将多余的属性放在一个新的 **文件记录** 里, 此属性用于描述在哪里找到这个新的 **文件记录**.
* 此属性非常少见.
